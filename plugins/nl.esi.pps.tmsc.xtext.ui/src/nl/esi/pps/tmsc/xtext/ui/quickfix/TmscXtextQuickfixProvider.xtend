/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////

/*
 * Generated by Xtext, all rights reserved ESI (TNO)
 */
package nl.esi.pps.tmsc.xtext.ui.quickfix

import nl.esi.pps.tmsc.xtext.validation.TmscXtextValidator
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import nl.esi.pps.tmsc.xtext.tmscXtext.XEvent
import nl.esi.pps.tmsc.xtext.tmscXtext.XInterface
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextFactory
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextModel
import nl.esi.pps.tmsc.xtext.tmscXtext.XEventType

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class TmscXtextQuickfixProvider extends DefaultQuickfixProvider {
    static extension val TmscXtextFactory m_tmsct = TmscXtextFactory.eINSTANCE
     
    @Fix(TmscXtextValidator.XINTERFACE_NOT_PROVIDED)
    def provideInterface(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, 'Provide interface', 'Provide the interface', null) [
            element, context |
            val xEvent = element as XEvent
            xEvent.component.provides += xEvent.function.operation.eContainer as XInterface
        ]
    }

    @Fix(TmscXtextValidator.XINTERFACE_NOT_REQUIRED)
    def requireInterface(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, 'Require interface', 'Require the interface', null) [
            element, context |
            val xEvent = element as XEvent
            xEvent.component.requires += xEvent.function.operation.eContainer as XInterface
        ]
    }
    
    @Fix(TmscXtextValidator.XEVENT_ORDER_CALL_STACK)
    def addExitEvent(Issue issue, IssueResolutionAcceptor acceptor) {
        val functionName = issue.data.head
        acceptor.accept(issue, '''Insert «functionName» function exit''', '''Inserts exit of function «functionName» just before this event.''', null) [
            element, context |
            val xEvent = element as XEvent
            val model = xEvent.eContainer as TmscXtextModel
            model.events.add(model.events.indexOf(xEvent), createXEvent => [
                function = model.functions.findFirst[name == functionName]
                type = XEventType::EXIT
                timestamp = xEvent.timestamp
                component = xEvent.component
                executor = xEvent.executor
            ])
        ]
    }
}
