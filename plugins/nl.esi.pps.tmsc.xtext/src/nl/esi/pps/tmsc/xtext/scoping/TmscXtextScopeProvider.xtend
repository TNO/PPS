/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////

/*
 * Generated by Xtext, all rights reserved ESI (TNO)
 */
package nl.esi.pps.tmsc.xtext.scoping

import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextPackage
import nl.esi.pps.tmsc.xtext.tmscXtext.XEvent
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.EcoreUtil2

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TmscXtextScopeProvider extends AbstractTmscXtextScopeProvider {
    override getScope(EObject context, EReference reference) {
        return switch (reference) {
        	case TmscXtextPackage.Literals.XEVENT_ARGUMENT__PARAMETER: {
        		val xEvent = EcoreUtil2::getContainerOfType(context, XEvent)
        		Scopes.scopeFor(xEvent.function.parameters)
        	}
        	default: {
                super.getScope(context, reference)
        	}
        }
    }
}
