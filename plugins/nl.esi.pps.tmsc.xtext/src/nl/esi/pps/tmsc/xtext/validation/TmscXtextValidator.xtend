/**
 * Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
// Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////

/*
 * generated by Xtext 2.22.0
 */
package nl.esi.pps.tmsc.xtext.validation

import java.util.EnumSet
import nl.esi.pps.common.jfreechart.rendering.RenderingPaint
import nl.esi.pps.common.jfreechart.rendering.RenderingStroke
import nl.esi.pps.tmsc.rendering.RenderingDependencies
import nl.esi.pps.tmsc.rendering.RenderingExecutions
import nl.esi.pps.tmsc.rendering.RenderingProperties
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextModel
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextPackage
import nl.esi.pps.tmsc.xtext.tmscXtext.XComponent
import nl.esi.pps.tmsc.xtext.tmscXtext.XDependency
import nl.esi.pps.tmsc.xtext.tmscXtext.XDependencySettings
import nl.esi.pps.tmsc.xtext.tmscXtext.XDependencyType
import nl.esi.pps.tmsc.xtext.tmscXtext.XEvent
import nl.esi.pps.tmsc.xtext.tmscXtext.XEventType
import nl.esi.pps.tmsc.xtext.tmscXtext.XFunction
import nl.esi.pps.tmsc.xtext.tmscXtext.XFunctionParameterKind
import nl.esi.pps.tmsc.xtext.tmscXtext.XInterface
import nl.esi.pps.tmsc.xtext.tmscXtext.XNamedArchitectureElement
import nl.esi.pps.tmsc.xtext.tmscXtext.XProperty
import nl.esi.pps.tmsc.xtext.tmscXtext.XPropertyStringValue
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.validation.Check

import static nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextPackage.Literals.XPROPERTY_STRING_VALUE__VALUE

import static extension nl.esi.pps.tmsc.xtext.TmscXtextQueries.*
import static extension org.eclipse.lsat.common.xtend.Queries.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TmscXtextValidator extends AbstractTmscXtextValidator {
    public static val UNIQUE_NAME_XNAMED_ARCHITECTURE_ELEMENT = 'uniqueXNamedArchitectureElement'

    @Check
    def checkUniqueXComponentName(XNamedArchitectureElement namedElement) {
        val feature = namedElement.eContainingFeature
        val siblings = (namedElement.eContainer.eGet(feature) as Iterable<XNamedArchitectureElement>).excluding(namedElement)
        if (siblings.exists[name == namedElement.name]) {
            // substring(1): strips the leading 'X' of the EClass name
            error('''«namedElement.eClass.name.substring(1)» name  «namedElement.name» should be unique''',
                TmscXtextPackage.Literals.XNAMED_ARCHITECTURE_ELEMENT__NAME, UNIQUE_NAME_XNAMED_ARCHITECTURE_ELEMENT)
        }
    }
    
    public static val UNIQUE_NAME_XDEPENDENCY = 'uniqueXDependencyName'

    @Check
    def checkUniqueXDependencyName(TmscXtextModel model) {
        model.events.flatMap[outgoingDependencies].groupBy[name].values.filter[size > 1].flatten.forEach [
            error('''«type.literal.toFirstUpper» «name» can be sent only once; ID should be unique''',
                it, TmscXtextPackage.Literals.XDEPENDENCY__NAME, UNIQUE_NAME_XDEPENDENCY)
        ]
    }

    public static val UNIQUE_NAME_XPROPERTY = 'uniqueXPropertyName'

    @Check
    def checkUniqueXPropertyName(XProperty xProperty) {
        val feature = xProperty.eContainingFeature
        val siblings = (xProperty.eContainer.eGet(feature) as Iterable<XProperty>).excluding(xProperty)
        if (siblings.exists[name == xProperty.name]) {
            error('''Property name «xProperty.name» should be unique''', TmscXtextPackage.Literals.XPROPERTY__NAME,
                UNIQUE_NAME_XPROPERTY)
        }
    }

    public static val UNIQUE_TYPE_XDEPENDENCY_DEFAULTS = 'uniqueXDependencyDefaultsType'

    @Check
    def checkUniqueXDependencyDefaultsType(XDependencySettings xDependencySettings) {
        if (xDependencySettings.getSiblingsOfType(XDependencySettings).exists[type == xDependencySettings.type]) {
            error('''Defaults can be set only once for type «xDependencySettings.type»''',
                TmscXtextPackage.Literals.XDEPENDENCY_SETTINGS__TYPE, UNIQUE_TYPE_XDEPENDENCY_DEFAULTS)
        }
    }

    public static val UNIQUE_PREFIX_XDEPENDENCY_DEFAULTS = 'uniqueXDependencyDefaultsPrefix'

    @Check
    def checkUniqueXDependencyDefaultsPrefix(XDependencySettings xDependencySettings) {
        if (xDependencySettings.prefix === null) {
            return
        }
        val siblings = xDependencySettings.getSiblingsOfType(XDependencySettings)
        val duplicates = siblings.map[prefix].filterNull.filter [ prefix |
            prefix.startsWith(xDependencySettings.prefix) || xDependencySettings.prefix.startsWith(prefix)
        ].sort
        if (!duplicates.isEmpty) {
            error('''Prefix «xDependencySettings.prefix» collides with «FOR duplicate : duplicates SEPARATOR ', '»«duplicate»«ENDFOR»''',
                TmscXtextPackage.Literals.XDEPENDENCY_SETTINGS__PREFIX, UNIQUE_PREFIX_XDEPENDENCY_DEFAULTS)
        }
    }

    public static val MULTIPLE_XDEPENDENCY_RECEIVE = 'multipleXDependencyReceive'

    @Check
    def checkMultipleXDependencyReceive(TmscXtextModel model) {
        val receives = newHashMap
        for (event : model.events) {
            event.incomingDependencies.forEach[d|receives.computeIfAbsent(d)[newArrayList] += event]
        }
        receives.filter[k, v|v.size > 1].forEach [ dependency, events |
            for (event : events) {
                error('''«dependency.type.literal.toFirstUpper» «dependency.name» can be received only once''',
                    event, TmscXtextPackage.Literals.XEVENT__INCOMING_DEPENDENCIES,
                    event.incomingDependencies.indexOf(dependency), MULTIPLE_XDEPENDENCY_RECEIVE)
            }
        ]
    }

    public static val XDEPENDENCY_TYPE_REPLY_REQUEST = 'xDependencyTypeReplyRequest'
    public static val XDEPENDENCY_REQUEST_TYPE_REQUEST = 'xDependencyRequestTypeRequest'

    @Check
    def checkXDependencyRequestReply(XDependency dependency) {
        if (dependency.request === null) {
            return
        }
        if (dependency.type != XDependencyType::REPLY) {
            error('Request is only applicable for a reply', TmscXtextPackage.Literals.XDEPENDENCY__REQUEST,
                XDEPENDENCY_TYPE_REPLY_REQUEST)
        }
        if (dependency.request.type != XDependencyType::REQUEST) {
            error('Request should be of type request', TmscXtextPackage.Literals.XDEPENDENCY__REQUEST,
                XDEPENDENCY_REQUEST_TYPE_REQUEST)
        }
    }
    
    public static val XDEPENDENCY_TYPE_MESSAGE_DETECT_MESSAGE = 'xDependencyTypeMessageControlMessage'
    public static val XDEPENDENCY_MESSAGE_TYPE_MESSAGE = 'xDependencyMessageTypeMessage'

    @Check
    def checkXDependencyMessageControlMessage(XDependency dependency) {
        if (dependency.message === null) {
            return
        }
        if (dependency.type != XDependencyType::MESSAGE_CONTROL) {
            error('Message is only applicable for a message-control', TmscXtextPackage.Literals.XDEPENDENCY__MESSAGE,
                XDEPENDENCY_TYPE_MESSAGE_DETECT_MESSAGE)
        }
        switch (dependency.message.type) {
        	case DOMAIN,
        	case LIFELINE_SEGMENT,
        	case MESSAGE_CONTROL: {
                error('Message should be of type message, request or reply', TmscXtextPackage.Literals.XDEPENDENCY__MESSAGE,
                    XDEPENDENCY_MESSAGE_TYPE_MESSAGE)
        	}
        	default: { /* Validation OK */ }
        }
    }

    public static val XFUNCTION_NOT_USED = 'xFunctionNotUsed'

    @Check
    def checkXFunctionNotUsed(XFunction xFunction) {
        if (!xFunction.getContainerOfType(TmscXtextModel).events.map[function].contains(xFunction)) {
            info('''Function «xFunction.name» is not used''', null, XFUNCTION_NOT_USED)
        }
    }
    
    public static val XCOMPONENT_NOT_USED = 'xComponentNotUsed'

    @Check
    def checkXComponentNotUsed(XComponent xComponent) {
        if (!xComponent.getContainerOfType(TmscXtextModel).events.map[component].contains(xComponent)) {
            info('''Component «xComponent.name» is not used''', null, XCOMPONENT_NOT_USED)
        }
    }
    
    public static val XFUNCTION_OPERATION = 'xFunctionOperation'

    @Check
    def checkXFunctionOperation(XFunction xFunction) {
        if (xFunction.operation === null && (xFunction.ipcClient || xFunction.ipcServer)) {
            error('Please specify an operation from which this IPC function originates.',
                TmscXtextPackage.Literals.XFUNCTION__OPERATION, XFUNCTION_OPERATION)
        }
    }

    public static val XINTERFACE_NOT_PROVIDED = 'xInterfaceNotProvided'

    @Check
    def checkXInterfaceNotProvided(XEvent xEvent) {
        val componentNode = NodeModelUtils.getNode(xEvent.component)
        if (componentNode === null) {
            // Only perform this validation when the component is explicitly defined in the syntax
            return
        }
        
        val xInterface = xEvent.function.operation?.eContainer as XInterface
        if (xEvent.function.ipcServer && !xEvent.component.provides.contains(xInterface)) {
            info('''Component «xEvent.component.name» does not provide interface «xInterface.name», though it executes ipc-server function «xEvent.function.name»''',
                TmscXtextPackage.Literals.XEVENT__FUNCTION, XINTERFACE_NOT_PROVIDED)
        }
    }

    public static val XINTERFACE_NOT_REQUIRED = 'xInterfaceNotRequired'

    @Check
    def checkXInterfaceNotRequired(XEvent xEvent) {
        val componentNode = NodeModelUtils.getNode(xEvent.component)
        if (componentNode === null) {
            // Only perform this validation when the component is explicitly defined in the syntax
            return
        }
        
        val xInterface = xEvent.function.operation?.eContainer as XInterface
        if (xEvent.function.ipcClient && !xEvent.component.requires.contains(xInterface)) {
            info('''Component «xEvent.component.name» does not require interface «xInterface.name», though it executes ipc-client function «xEvent.function.name»''',
                TmscXtextPackage.Literals.XEVENT__FUNCTION, XINTERFACE_NOT_REQUIRED)
        }
    }
    
    public static val XEVENT_ARGUMENT_KIND_NOT_EXPECTED = 'xEventArgumentKindNotExpected'

    @Check
    def checkXEventArgumentKindNotExpected(XEvent xEvent) {
        val parameterKinds = xEvent.type == XEventType::ENTRY ? 
            EnumSet::of(XFunctionParameterKind::IN, XFunctionParameterKind::IN_OUT) : 
            EnumSet::of(XFunctionParameterKind::IN_OUT, XFunctionParameterKind::OUT, XFunctionParameterKind::RETURN)
        xEvent.arguments.reject[parameterKinds.contains(parameter.kind)].forEach [ arg |
            warning('''«arg.parameter.kind.literal.toFirstUpper» parameter '«arg.parameter.name»' is not expected on an «xEvent.type.getName.toLowerCase» event''',
                arg, TmscXtextPackage.Literals.XEVENT_ARGUMENT__PARAMETER, XEVENT_ARGUMENT_KIND_NOT_EXPECTED)
        ]
    }
    
    public static val XEVENT_ORDER_TIME = 'xEventOrderTime'
    public static val XEVENT_ORDER_CALL_STACK = 'xEventOrderCallStack'
    
    @Check(NORMAL)
    def checkXEventOrder(TmscXtextModel model) {
        for (executorEvents : model.events.groupBy[executor].values) {
            // Check if the events are correctly ordered in time
            executorEvents.fold(null) [ maxTimestamp, event |
                if (maxTimestamp !== null && event.timestamp !== null && event.timestamp < maxTimestamp) {
                    error('Events should be ordered in time per executor', event,
                        TmscXtextPackage.Literals.XEVENT__TIMESTAMP, XEVENT_ORDER_TIME)
                }
                return event.timestamp ?: maxTimestamp
            ]
            
            // Check if events correctly denote call-stacks 
            executorEvents.fold(newLinkedList) [ callStack, event |
                if (event.type == XEventType::ENTRY) {
                    callStack.push(event.function)
                } else if (!callStack.isEmpty) {
                    val expectedFunction = callStack.pop
                    if (event.function != expectedFunction) {
                        error('''Expected exit of function «expectedFunction.name» on executor «event.executor.name». This is caused by missing events or incorrect ordering of events.''',
                            event, TmscXtextPackage.Literals.XEVENT__FUNCTION, XEVENT_ORDER_CALL_STACK,
                            expectedFunction.name)
                        // Clear the call-stack to avoid causal errors
                        callStack.clear
                    }
                }
                return callStack
            ]
        }
    }
    
    @Check
    def checkXRenderingPropertyValue(XPropertyStringValue propertyValue) {
        val property = propertyValue.eContainer
        if (property instanceof XProperty) {
            switch (property.name) {
                case null:
                    return
                case RenderingProperties::PROPERTY_PAINT: {
                    if (propertyValue.value.startsWith('#')) {
                        try {
                            RenderingProperties::decodeColor(propertyValue.value)
                        } catch (NumberFormatException e) {
                            warning('Cannot parse color: ' + e.message, XPROPERTY_STRING_VALUE__VALUE);
                        }
                    } else {
                        try {
                            Enum::valueOf(RenderingPaint, propertyValue.value);
                        } catch (IllegalArgumentException e) {
                            warning('Paint not defined, use Ctrl+Space for alternatives.',
                                XPROPERTY_STRING_VALUE__VALUE)
                        }
                    }
                }
                case RenderingProperties::PROPERTY_STROKE: {
                    try {
                        Enum::valueOf(RenderingStroke, propertyValue.value);
                    } catch (IllegalArgumentException e) {
                        warning('Stroke not defined, use Ctrl+Space for alternatives.', XPROPERTY_STRING_VALUE__VALUE)
                    }
                }
                case RenderingProperties::PROPERTY_RENDERING_DEPENDENCIES: {
                    try {
                        Enum::valueOf(RenderingDependencies, propertyValue.value);
                    } catch (IllegalArgumentException e) {
                        warning('Value not defined, use Ctrl+Space for alternatives.', XPROPERTY_STRING_VALUE__VALUE)
                    }
                }
                case RenderingProperties::PROPERTY_RENDERING_EXECUTIONS: {
                    try {
                        Enum::valueOf(RenderingExecutions, propertyValue.value);
                    } catch (IllegalArgumentException e) {
                        warning('Value not defined, use Ctrl+Space for alternatives.', XPROPERTY_STRING_VALUE__VALUE)
                    }
                }
            }
        }
    }
}
