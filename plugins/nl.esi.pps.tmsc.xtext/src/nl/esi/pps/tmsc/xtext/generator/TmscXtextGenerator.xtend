/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////

/*
 * generated by Xtext 2.22.0
 */
package nl.esi.pps.tmsc.xtext.generator

import com.google.inject.Inject
import java.io.IOException
import nl.esi.pps.architecture.ArchitecturePlugin
import nl.esi.pps.tmsc.TmscPlugin
import nl.esi.pps.tmsc.analysis.DefaultScheduledDependencyAnalysis
import nl.esi.pps.tmsc.metric.MetricFactory
import nl.esi.pps.tmsc.metric.MetricPlugin
import nl.esi.pps.tmsc.provider.TmscEditPlugin
import nl.esi.pps.tmsc.xtext.services.TmscXtextGrammarAccess
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextModel
import org.eclipse.core.runtime.IStatus
import org.eclipse.core.runtime.Status
import org.eclipse.emf.common.notify.Notifier
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.ICompositeNode

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TmscXtextGenerator extends AbstractGenerator {
    @Inject
    @Extension
    var TmscXtextGrammarAccess tmscXtextGrammarAccess;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val xtextTmsc = resource.contents.filter(TmscXtextModel).head
        if (xtextTmsc === null) {
            return
        }
        val tmsc = doTransform(xtextTmsc)

	    val tmscFileName = resource.URI.trimFileExtension.lastSegment
	    val tmscResourceSet = TmscEditPlugin::createResourceSet
	    val tmscURI = fsa.getURI('''«tmscFileName».«TmscPlugin::TMSC_FILE_EXTENSION_XMI»''')
	    val tmscResource = tmscResourceSet.createResource(tmscURI)
	    tmscResource.contents += tmsc
	    
	    switch (xtextTmsc.architectureKind) {
	    	case INTERNAL: {
                tmscResource.contents += tmsc.architectures
	    	}
	    	case EXTERNAL: {
                val archURI = fsa.getURI('''«tmscFileName».«ArchitecturePlugin::ARCHITECTURE_FILE_EXTENSION_XMI»''')
                val archResource = tmscResourceSet.createResource(archURI)
                archResource.contents += tmsc.architectures
                try {
                    archResource.save(null)
                } catch (IOException e) {
                    TmscEditPlugin::INSTANCE.log(new Status(IStatus.ERROR, class, 'Failed to save architecture: ' + e.message, e))
                    return
                }
	    	}
	    }

        val metricModel = MetricFactory.eINSTANCE.createMetricModel
        MetricPlugin.plugin.getRegisteredMetricProcessors(tmsc).values.forEach [ p |
            p.analyse(tmsc, metricModel)
        ]
        if (!metricModel.metrics.isEmpty) {
            tmscResource.contents += metricModel
        }
        
	    try {
            tmscResource.save(null)
	    } catch (IOException e) {
            TmscEditPlugin::INSTANCE.log(new Status(IStatus.ERROR, class, 'Failed to save tmsc: ' + e.message, e))
            return
	    }
	}
	
	def private doTransform(TmscXtextModel tmscXtext) {
	    // TMSC epoch time is derived from the fact if ISO8601 time-stamps are used in the Xtext model
	    val eventGrammarElements = tmscXtext.events.map[adapt(ICompositeNode)].flatMap[children].map[grammarElement]
	    val containsISO8601 = eventGrammarElements.contains(tmscXtextGrammarAccess.XEventAccess.timestampISO8601TerminalRuleCall_0_0_0)
	    
	    return new TmscXtextToTmscTransformation().transform(tmscXtext) => [ tmsc |
	        tmsc.epochTime = containsISO8601
        
            // Use false to allow the end-user to override the default scheduled value
            new DefaultScheduledDependencyAnalysis().analyzeScheduledDependencies(tmsc, false)
	    ]
	}
	
	def static <T> T adapt(Notifier notifier, Class<T> adapterType) {
	    return EcoreUtil::getAdapter(notifier.eAdapters, adapterType) as T
	}
}
