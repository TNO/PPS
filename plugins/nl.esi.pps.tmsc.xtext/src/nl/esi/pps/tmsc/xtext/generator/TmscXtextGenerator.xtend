/**
 * Copyright (c) 2018-2025 TNO and Contributors to the GitHub community
 * 
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 * 
 * SPDX-License-Identifier: MIT
 */
// Copyright (c) 2018-2023 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////
/*
 * generated by Xtext 2.22.0
 */
package nl.esi.pps.tmsc.xtext.generator

import com.google.inject.Inject
import java.io.IOException
import nl.esi.pps.architecture.ArchitecturePlugin
import nl.esi.pps.tmsc.TmscPlugin
import nl.esi.pps.tmsc.analysis.DefaultScheduledDependencyAnalysis
import nl.esi.pps.tmsc.analysis.DefaultTimeBoundAnalysis
import nl.esi.pps.tmsc.metric.MetricFactory
import nl.esi.pps.tmsc.metric.MetricPlugin
import nl.esi.pps.tmsc.provider.TmscEditPlugin
import nl.esi.pps.tmsc.xtext.services.TmscXtextGrammarAccess
import nl.esi.pps.tmsc.xtext.tmscXtext.TmscXtextModel
import nl.esi.pps.tmsc.xtext.tmscXtext.XTimeBoundAnalysis
import org.eclipse.core.runtime.IStatus
import org.eclipse.core.runtime.Status
import org.eclipse.emf.common.notify.Notifier
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.ICompositeNode

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TmscXtextGenerator extends AbstractGenerator {
    @Inject
    @Extension
    var TmscXtextGrammarAccess tmscXtextGrammarAccess;

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val xtextTmsc = resource.contents.filter(TmscXtextModel).head
        if (xtextTmsc === null) {
            return
        }
        val tmsc = doTransform(xtextTmsc)

        val tmscFileName = resource.URI.trimFileExtension.lastSegment
        val tmscResourceSet = TmscEditPlugin::createResourceSet
        val tmscURI = fsa.getURI('''«tmscFileName».«TmscPlugin::TMSC_FILE_EXTENSION_XMI»''')
        val tmscResource = tmscResourceSet.createResource(tmscURI)
        tmscResource.contents += tmsc

        switch (xtextTmsc.architectureKind) {
            case INTERNAL: {
                tmscResource.contents += tmsc.architectures
            }
            case EXTERNAL: {
                val archURI = fsa.getURI('''«tmscFileName».«ArchitecturePlugin::ARCHITECTURE_FILE_EXTENSION_XMI»''')
                val archResource = tmscResourceSet.createResource(archURI)
                archResource.contents += tmsc.architectures
                try {
                    archResource.save(null)
                } catch (IOException e) {
                    TmscEditPlugin::INSTANCE.log(new Status(IStatus.ERROR, class, 'Failed to save architecture: ' + e.message, e))
                    return
                }
            }
        }

        val metricModel = MetricFactory.eINSTANCE.createMetricModel
        MetricPlugin.plugin.getRegisteredMetricProcessors(tmsc).values.forEach [ p |
            p.analyse(tmsc, metricModel)
        ]
        if (!metricModel.metrics.isEmpty) {
            tmscResource.contents += metricModel
        }

        // TODO: When more analyzes are supported, refactor this code to us a dispatch method per analysis
        for (analysis : xtextTmsc.analyses) {
            switch (analysis) {
                XTimeBoundAnalysis: {
                    val defaultTimeBound = TmscXtextToTmscTransformation.toNanos(analysis.getDefaultTimeBound())
                    new DefaultTimeBoundAnalysis(defaultTimeBound ?: 0L).analyzeTimeBounds(tmsc)
                }
            }
        }

        try {
            tmscResource.save(null)
        } catch (IOException e) {
            TmscEditPlugin::INSTANCE.log(new Status(IStatus.ERROR, class, 'Failed to save tmsc: ' + e.message, e))
            return
        }
    }

    def private doTransform(TmscXtextModel tmscXtext) {
        // TMSC epoch time is derived from the fact if ISO8601 time-stamps are used in the Xtext model
        val eventGrammarElements = tmscXtext.events.map[adapt(ICompositeNode)].flatMap[children].map[grammarElement]
	    val containsISO8601 = eventGrammarElements.contains(tmscXtextGrammarAccess.XEventAccess.timestampISO8601TerminalRuleCall_0_0_0)

        return new TmscXtextToTmscTransformation().transform(tmscXtext) => [ tmsc |
            tmsc.epochTime = containsISO8601

            // Use false to allow the end-user to override the default scheduled value
            new DefaultScheduledDependencyAnalysis().analyzeScheduledDependencies(tmsc, false)
        ]
    }

    def static <T> T adapt(Notifier notifier, Class<T> adapterType) {
        return EcoreUtil::getAdapter(notifier.eAdapters, adapterType) as T
    }
}
